{"version":3,"file":"static/chunks/6195-5593bc666c1eae34.js","mappings":"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","sources":["webpack://_N_E/../../node_modules/react-error-boundary/dist/react-error-boundary.esm.js","webpack://_N_E/../../node_modules/react-resizable-panels/dist/react-resizable-panels.esm.js","webpack://_N_E/<anon>"],"sourcesContent":["'use client';\nimport { createContext, Component, isValidElement, createElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (isValidElement(fallback)) {\n        childToRender = fallback;\n      } else if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else {\n        throw new Error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n  return true;\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context === null || context === void 0 ? void 0 : context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context === null || context === void 0 ? void 0 : context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n","import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[\"useId\".toString()];\n\nconst canUseEffectHooks = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nconst useIsomorphicLayoutEffect = canUseEffectHooks ? useLayoutEffect : () => {};\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idRef.current;\n}\n\nconst PanelGroupContext = createContext(null);\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = 100,\n  minSize = 10,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const panelId = useUniqueId(idFromProps);\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onCollapse,\n    onResize\n  });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n\n  // Basic props validation\n  if (minSize < 0 || minSize > 100) {\n    throw Error(`Panel minSize must be between 0 and 100, but was ${minSize}`);\n  } else if (maxSize < 0 || maxSize > 100) {\n    throw Error(`Panel maxSize must be between 0 and 100, but was ${maxSize}`);\n  } else {\n    if (defaultSize !== null) {\n      if (defaultSize < 0 || defaultSize > 100) {\n        throw Error(`Panel defaultSize must be between 0 and 100, but was ${defaultSize}`);\n      } else if (minSize > defaultSize && !collapsible) {\n        console.error(`Panel minSize ${minSize} cannot be greater than defaultSize ${defaultSize}`);\n        defaultSize = minSize;\n      }\n    }\n  }\n  const style = getPanelStyle(panelId, defaultSize);\n  const committedValuesRef = useRef({\n    size: parseSizeFromStyle(style)\n  });\n  const panelDataRef = useRef({\n    callbacksRef,\n    collapsible,\n    defaultSize,\n    id: panelId,\n    maxSize,\n    minSize,\n    order\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.size = parseSizeFromStyle(style);\n    panelDataRef.current.callbacksRef = callbacksRef;\n    panelDataRef.current.collapsible = collapsible;\n    panelDataRef.current.defaultSize = defaultSize;\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.maxSize = maxSize;\n    panelDataRef.current.minSize = minSize;\n    panelDataRef.current.order = order;\n  });\n  useIsomorphicLayoutEffect(() => {\n    registerPanel(panelId, panelDataRef);\n    return () => {\n      unregisterPanel(panelId);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => collapsePanel(panelId),\n    expand: () => expandPanel(panelId),\n    getCollapsed() {\n      return committedValuesRef.current.size === 0;\n    },\n    getSize() {\n      return committedValuesRef.current.size;\n    },\n    resize: percentage => resizePanel(panelId, percentage)\n  }), [collapsePanel, expandPanel, panelId, resizePanel]);\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps\n    }\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style) {\n  const {\n    flexGrow\n  } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow;\n  }\n}\n\nconst PRECISION = 10;\n\nfunction adjustByDelta(event, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse, initialDragState) {\n  const {\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  if (delta === 0) {\n    return baseSizes;\n  }\n  const panelsArray = panelsMapToSortedArray(panels);\n  const nextSizes = baseSizes.concat();\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = delta < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const nextSize = safeResizePanel(panel, Math.abs(delta), baseSize, event);\n    if (baseSize === nextSize) {\n      // If there's no room for the pivot panel to grow, we can ignore this drag update.\n      return baseSizes;\n    } else {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, baseSize);\n      }\n      delta = delta < 0 ? baseSize - nextSize : nextSize - baseSize;\n    }\n  }\n  let pivotId = delta < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n    const nextSize = safeResizePanel(panel, 0 - deltaRemaining, baseSize, event);\n    if (baseSize !== nextSize) {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n      }\n      deltaApplied += baseSize - nextSize;\n      nextSizes[index] = nextSize;\n      if (deltaApplied.toPrecision(PRECISION).localeCompare(Math.abs(delta).toPrecision(PRECISION), undefined, {\n        numeric: true\n      }) >= 0) {\n        break;\n      }\n    }\n    if (delta < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return baseSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = delta < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  nextSizes[index] = baseSizes[index] + deltaApplied;\n  return nextSizes;\n}\nfunction callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap) {\n  sizes.forEach((size, index) => {\n    const {\n      callbacksRef,\n      collapsible,\n      id\n    } = panelsArray[index].current;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n    if (lastNotifiedSize !== size) {\n      panelIdToLastNotifiedSizeMap[id] = size;\n      const {\n        onCollapse,\n        onResize\n      } = callbacksRef.current;\n      if (onResize) {\n        onResize(size);\n      }\n      if (collapsible && onCollapse) {\n        // Falsy check handles both previous size of 0\n        // and initial size of undefined (when mounting)\n        if (!lastNotifiedSize && size !== 0) {\n          onCollapse(false);\n        } else if (lastNotifiedSize !== 0 && size === 0) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\nfunction getBeforeAndAfterIds(id, panelsArray) {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n  return [idBefore, idAfter];\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction getFlexGrow(panels, id, sizes) {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n  const panelsArray = panelsMapToSortedArray(panels);\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n  return size.toPrecision(PRECISION);\n}\nfunction getPanel(id) {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getPanelGroup(id) {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandle(id) {\n  const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandleIndex(id) {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index ?? null;\n}\nfunction getResizeHandles() {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\nfunction getResizeHandlesForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = panelsArray[index]?.current?.id ?? null;\n  const idAfter = panelsArray[index + 1]?.current?.id ?? null;\n  return [idBefore, idAfter];\n}\nfunction panelsMapToSortedArray(panels) {\n  return Array.from(panels.values()).sort((panelA, panelB) => {\n    const orderA = panelA.current.order;\n    const orderB = panelB.current.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction safeResizePanel(panel, delta, prevSize, event) {\n  const nextSizeUnsafe = prevSize + delta;\n  if (panel.current.collapsible) {\n    if (prevSize > 0) {\n      // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n      if (nextSizeUnsafe <= panel.current.minSize / 2) {\n        return 0;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSizeUnsafe < panel.current.minSize) {\n          return 0;\n        }\n      }\n    }\n  }\n  const nextSize = Math.min(panel.current.maxSize, Math.max(panel.current.minSize, nextSizeUnsafe));\n  return nextSize;\n}\n\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse\n}) {\n  useEffect(() => {\n    const {\n      direction,\n      panels\n    } = committedValuesRef.current;\n    const groupElement = getPanelGroup(groupId);\n    const {\n      height,\n      width\n    } = groupElement.getBoundingClientRect();\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      let minSize = 0;\n      let maxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach(panelData => {\n        if (panelData.current.id === idBefore) {\n          maxSize = panelData.current.maxSize;\n          minSize = panelData.current.minSize;\n        } else {\n          totalMinSize += panelData.current.minSize;\n          totalMaxSize += panelData.current.maxSize;\n        }\n      });\n      const ariaValueMax = Math.min(maxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(minSize, (panelsArray.length - 1) * 100 - totalMaxSize);\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelsArray.findIndex(panel => panel.current.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelsArray[index];\n                const size = sizes[index];\n                if (size != null) {\n                  let delta = 0;\n                  if (size.toPrecision(PRECISION) <= panelData.current.minSize.toPrecision(PRECISION)) {\n                    delta = direction === \"horizontal\" ? width : height;\n                  } else {\n                    delta = -(direction === \"horizontal\" ? width : height);\n                  }\n                  const nextSizes = adjustByDelta(event, panels, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current, null);\n                  if (sizes !== nextSizes) {\n                    setSizes(nextSizes);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n        handle.removeEventListener(\"keydown\", onKeyDown);\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [committedValuesRef, groupId, panels, panelSizeBeforeCollapse, setSizes, sizes]);\n}\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const handles = getResizeHandles();\n            const index = getResizeHandleIndex(handleId);\n            assert(index !== null);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getDragOffset(event, handleId, direction, initialOffset = 0, initialHandleElementRect = null) {\n  const isHorizontal = direction === \"horizontal\";\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n  const handleElement = getResizeHandle(handleId);\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragState) {\n  const {\n    dragOffset = 0,\n    dragHandleRect,\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    const groupElement = getPanelGroup(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(panel => panel.current.id === targetPanelId);\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.current.collapsible) {\n      const baseSize = baseSizes[targetPanelIndex];\n      if (baseSize === 0 || baseSize.toPrecision(PRECISION) === targetPanel.current.minSize.toPrecision(PRECISION)) {\n        movement = movement < 0 ? -targetPanel.current.minSize * groupSizeInPixels : targetPanel.current.minSize * groupSizeInPixels;\n      }\n    }\n    return movement;\n  } else {\n    return getDragOffset(event, handleId, direction, dragOffset, dragHandleRect);\n  }\n}\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n  }\n}\nfunction setGlobalCursorStyle(state) {\n  if (currentState === state) {\n    return;\n  }\n  currentState = state;\n  const style = getCursorStyle(state);\n  if (element === null) {\n    element = document.createElement(\"style\");\n    document.head.appendChild(element);\n  }\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n  return panels.map(panel => {\n    const {\n      minSize,\n      order\n    } = panel.current;\n    return order ? `${order}:${minSize}` : `${minSize}`;\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelLayout(autoSaveId, panels, storage) {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] ?? null;\n  }\n  return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nconst debounceMap = {};\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\n\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\n// TODO\n// Within an active drag, remember original positions to refine more easily on expand.\n// Look at what the Chrome devtools Sources does.\nfunction PanelGroupWithForwardedRef({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  disablePointerEventsDuringResize = false,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout,\n  storage = defaultStorage,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const [activeHandleId, setActiveHandleId] = useState(null);\n  const [panels, setPanels] = useState(new Map());\n\n  // When resizing is done via mouse/touch event\n  // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const initialDragStateRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onLayout\n  });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState([]);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef({\n    direction,\n    panels,\n    sizes\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getLayout: () => {\n      const {\n        sizes\n      } = committedValuesRef.current;\n      return sizes;\n    },\n    setLayout: sizes => {\n      const total = sizes.reduce((accumulated, current) => accumulated + current, 0);\n      assert(total === 100, \"Panel sizes must add up to 100%\");\n      const {\n        panels\n      } = committedValuesRef.current;\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n      setSizes(sizes);\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.panels = panels;\n    committedValuesRef.current.sizes = sizes;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const {\n      onLayout\n    } = callbacksRef.current;\n    if (onLayout) {\n      const {\n        panels,\n        sizes\n      } = committedValuesRef.current;\n\n      // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n      if (sizes.length > 0) {\n        onLayout(sizes);\n        const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n        // When possible, we notify before the next render so that rendering work can be batched together.\n        // Some cases are difficult to detect though,\n        // for example panels that are conditionally rendered can affect the size of neighboring panels.\n        // In this case, the best we can do is notify on commit.\n        // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n        const panelsArray = panelsMapToSortedArray(panels);\n        callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n      }\n    }\n  }, [sizes]);\n\n  // Once all panels have registered themselves,\n  // Compute the initial sizes based on default weights.\n  // This assumes that panels register during initial mount (no conditional rendering)!\n  useIsomorphicLayoutEffect(() => {\n    const sizes = committedValuesRef.current.sizes;\n    if (sizes.length === panels.size) {\n      // Only compute (or restore) default sizes once per panel configuration.\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let defaultSizes = null;\n    if (autoSaveId) {\n      const panelsArray = panelsMapToSortedArray(panels);\n      defaultSizes = loadPanelLayout(autoSaveId, panelsArray, storage);\n    }\n    if (defaultSizes != null) {\n      setSizes(defaultSizes);\n    } else {\n      const panelsArray = panelsMapToSortedArray(panels);\n      let panelsWithNullDefaultSize = 0;\n      let totalDefaultSize = 0;\n      let totalMinSize = 0;\n\n      // TODO\n      // Implicit default size calculations below do not account for inferred min/max size values.\n      // e.g. if Panel A has a maxSize of 40 then Panels A and B can't both have an implicit default size of 50.\n      // For now, these logic edge cases are left to the user to handle via props.\n\n      panelsArray.forEach(panel => {\n        totalMinSize += panel.current.minSize;\n        if (panel.current.defaultSize === null) {\n          panelsWithNullDefaultSize++;\n        } else {\n          totalDefaultSize += panel.current.defaultSize;\n        }\n      });\n      if (totalDefaultSize > 100) {\n        throw new Error(`Default panel sizes cannot exceed 100%`);\n      } else if (panelsArray.length > 1 && panelsWithNullDefaultSize === 0 && totalDefaultSize !== 100) {\n        throw new Error(`Invalid default sizes specified for panels`);\n      } else if (totalMinSize > 100) {\n        throw new Error(`Minimum panel sizes cannot exceed 100%`);\n      }\n      setSizes(panelsArray.map(panel => {\n        if (panel.current.defaultSize === null) {\n          return (100 - totalDefaultSize) / panelsWithNullDefaultSize;\n        }\n        return panel.current.defaultSize;\n      }));\n    }\n  }, [autoSaveId, panels, storage]);\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n    }\n  }, [autoSaveId, panels, sizes, storage]);\n  const getPanelStyle = useCallback((id, defaultSize) => {\n    const {\n      panels\n    } = committedValuesRef.current;\n\n    // Before mounting, Panels will not yet have registered themselves.\n    // This includes server rendering.\n    // At this point the best we can do is render everything with the same size.\n    if (panels.size === 0) {\n      return {\n        flexBasis: 0,\n        flexGrow: defaultSize != null ? defaultSize : undefined,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\"\n      };\n    }\n    const flexGrow = getFlexGrow(panels, id, sizes);\n    return {\n      flexBasis: 0,\n      flexGrow,\n      flexShrink: 1,\n      // Without this, Panel sizes may be unintentionally overridden by their content.\n      overflow: \"hidden\",\n      // Disable pointer events inside of a panel during resize.\n      // This avoid edge cases like nested iframes.\n      pointerEvents: disablePointerEventsDuringResize && activeHandleId !== null ? \"none\" : undefined\n    };\n  }, [activeHandleId, disablePointerEventsDuringResize, sizes]);\n  const registerPanel = useCallback((id, panelRef) => {\n    setPanels(prevPanels => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panelRef);\n      return nextPanels;\n    });\n  }, []);\n  const registerResizeHandle = useCallback(handleId => {\n    const resizeHandler = event => {\n      event.preventDefault();\n      const {\n        direction,\n        panels,\n        sizes: prevSizes\n      } = committedValuesRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return;\n      }\n      let movement = getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragStateRef.current);\n      if (movement === 0) {\n        return;\n      }\n      const groupElement = getPanelGroup(groupId);\n      const rect = groupElement.getBoundingClientRect();\n      const isHorizontal = direction === \"horizontal\";\n\n      // Support RTL layouts\n      if (document.dir === \"rtl\" && isHorizontal) {\n        movement = -movement;\n      }\n      const size = isHorizontal ? rect.width : rect.height;\n      const delta = movement / size * 100;\n      const nextSizes = adjustByDelta(event, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, initialDragStateRef.current);\n      const sizesChanged = !areEqual(prevSizes, nextSizes);\n\n      // Don't update cursor for resizes triggered by keyboard interactions.\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          if (!sizesChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(movement < 0 ? \"horizontal-min\" : \"horizontal-max\");\n            } else {\n              setGlobalCursorStyle(movement < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n      if (sizesChanged) {\n        const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n        // If resize change handlers have been declared, this is the time to call them.\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n        setSizes(nextSizes);\n      }\n      prevDeltaRef.current = delta;\n    };\n    return resizeHandler;\n  }, [groupId]);\n  const unregisterPanel = useCallback(id => {\n    setPanels(prevPanels => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n      return nextPanels;\n    });\n  }, []);\n  const collapsePanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null || !panel.current.collapsible) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === 0) {\n      // Panel is already collapsed.\n      return;\n    }\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : 0 - currentSize;\n    const nextSizes = adjustByDelta(null, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // If resize change handlers have been declared, this is the time to call them.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      setSizes(nextSizes);\n    }\n  }, []);\n  const expandPanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || panel.current.minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize !== 0) {\n      // Panel is already expanded.\n      return;\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? 0 - sizeBeforeCollapse : sizeBeforeCollapse;\n    const nextSizes = adjustByDelta(null, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // If resize change handlers have been declared, this is the time to call them.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      setSizes(nextSizes);\n    }\n  }, []);\n  const resizePanel = useCallback((id, nextSize) => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === nextSize) {\n      return;\n    }\n    if (panel.current.collapsible && nextSize === 0) ; else {\n      nextSize = Math.min(panel.current.maxSize, Math.max(panel.current.minSize, nextSize));\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n    const nextSizes = adjustByDelta(null, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // If resize change handlers have been declared, this is the time to call them.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      setSizes(nextSizes);\n    }\n  }, []);\n  const context = useMemo(() => ({\n    activeHandleId,\n    collapsePanel,\n    direction,\n    expandPanel,\n    getPanelStyle,\n    groupId,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging: (id, event) => {\n      setActiveHandleId(id);\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        const handleElement = getResizeHandle(id);\n        initialDragStateRef.current = {\n          dragHandleRect: handleElement.getBoundingClientRect(),\n          dragOffset: getDragOffset(event, id, direction),\n          sizes: committedValuesRef.current.sizes\n        };\n      }\n    },\n    stopDragging: () => {\n      resetGlobalCursorStyle();\n      setActiveHandleId(null);\n      initialDragStateRef.current = null;\n    },\n    unregisterPanel\n  }), [activeHandleId, collapsePanel, direction, expandPanel, getPanelStyle, groupId, registerPanel, registerResizeHandle, resizePanel, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      style: {\n        ...style,\n        ...styleFromProps\n      }\n    }),\n    value: context\n  });\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const divElementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current;\n    div.blur();\n    stopDragging();\n    const {\n      onDragging\n    } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n    const onMove = event => {\n      resizeHandler(event);\n    };\n    const onMouseLeave = event => {\n      resizeHandler(event);\n    };\n    const divElement = divElementRef.current;\n    const targetDocument = divElement.ownerDocument;\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n    return () => {\n      targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler\n  });\n  const style = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex: 0\n  });\n}\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nexport { Panel, PanelGroup, PanelResizeHandle };\n"],"names":["ErrorBoundaryContext","react__WEBPACK_IMPORTED_MODULE_0__","createContext","initialState","didCatch","error","ErrorBoundary","Component","constructor","props","resetErrorBoundary","bind","state","getDerivedStateFromError","_this$props$onReset","_this$props","_len","arguments","length","args","_key","onReset","call","reason","setState","componentDidCatch","info","_this$props$onError","_this$props2","onError","componentDidUpdate","prevProps","prevState","resetKeys","hasArrayChanged","a","undefined","b","some","item","index","Object","is","_this$props$onReset2","_this$props3","next","prev","render","children","fallbackRender","FallbackComponent","fallback","childToRender","isValidElement","createElement","Provider","value","forwardRef","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useRef","useState","react__WEBPACK_IMPORTED_MODULE_0___namespace_cache","__webpack_require__","t","useId","toString","canUseEffectHooks","window","document","useIsomorphicLayoutEffect","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","current","PanelGroupContext","PanelWithForwardedRef","className","classNameFromProps","collapsible","defaultSize","forwardedRef","id","idFromProps","maxSize","minSize","onCollapse","onResize","order","style","styleFromProps","tagName","Type","context","Error","panelId","collapsePanel","expandPanel","getPanelStyle","registerPanel","resizePanel","unregisterPanel","callbacksRef","console","committedValuesRef","size","parseSizeFromStyle","panelDataRef","collapse","expand","getCollapsed","getSize","resize","percentage","parseFloat","flexGrow","toFixed","displayName","Panel","ref","adjustByDelta","event","panels","idBefore","idAfter","delta","prevSizes","panelSizeBeforeCollapse","initialDragState","sizes","initialSizes","baseSizes","panelsArray","panelsMapToSortedArray","nextSizes","concat","deltaApplied","pivotId","findIndex","panel","baseSize","nextSize","safeResizePanel","Math","abs","set","deltaRemaining","toPrecision","localeCompare","numeric","callPanelCallbacks","panelIdToLastNotifiedSizeMap","forEach","lastNotifiedSize","getBeforeAndAfterIds","isLastPanel","getFlexGrow","getPanelGroup","element","querySelector","getResizeHandle","getResizeHandles","Array","from","querySelectorAll","getResizeHandlesForGroup","groupId","getResizeHandlePanelIds","handleId","handle","handles","indexOf","values","sort","panelA","panelB","orderA","orderB","prevSize","nextSizeUnsafe","isKeyboardEvent","type","startsWith","min","max","assert","expectedCondition","message","getDragOffset","direction","initialOffset","initialHandleElementRect","isHorizontal","pointerOffset","isMouseEvent","clientX","clientY","isTouchEvent","firstTouch","touches","screenX","screenY","handleElement","rect","getBoundingClientRect","elementOffset","left","top","currentState","getCursorStyle","setGlobalCursorStyle","head","appendChild","innerHTML","getSerializationKey","map","join","loadSerializedPanelGroupState","autoSaveId","storage","serialized","getItem","parsed","JSON","parse","savePanelGroupLayout","key","setItem","stringify","debounceMap","initializeDefaultStorage","storageObject","localStorage","name","defaultStorage","PanelGroupWithForwardedRef","disablePointerEventsDuringResize","onLayout","activeHandleId","setActiveHandleId","setPanels","Map","initialDragStateRef","panelIdToLastNotifiedSizeMapRef","setSizes","prevDeltaRef","getLayout","setLayout","total","reduce","accumulated","useWindowSplitterPanelGroupBehavior","groupElement","height","width","cleanupFunctions","getAttribute","totalMinSize","totalMaxSize","panelData","ariaValueMax","ariaValueMin","setAttribute","round","parseInt","onKeyDown","defaultPrevented","preventDefault","addEventListener","panelBefore","getPanel","removeAttribute","removeEventListener","cleanupFunction","defaultSizes","loadPanelLayout","panelsWithNullDefaultSize","totalDefaultSize","debounce","callback","durationMs","timeoutId","clearTimeout","setTimeout","flexBasis","flexShrink","overflow","pointerEvents","panelRef","prevPanels","has","nextPanels","registerResizeHandle","resizeHandler","movement","getMovement","dragOffset","dragHandleRect","groupSizeInPixels","denominator","shiftKey","targetPanelId","targetPanelIndex","targetPanel","dir","sizesChanged","areEqual","arrayA","arrayB","delete","get","currentSize","sizeBeforeCollapse","startDragging","stopDragging","removeChild","display","flexDirection","PanelGroup","PanelResizeHandle","disabled","onDragging","divElementRef","panelGroupContext","resizeHandleId","isDragging","isFocused","setIsFocused","setResizeHandler","stopDraggingAndBlur","div","blur","onMove","onMouseLeave","divElement","targetDocument","ownerDocument","body","useWindowSplitterResizeHandlerBehavior","getResizeHandleIndex","nextIndex","nextHandle","focus","cursor","touchAction","userSelect","onBlur","onFocus","onMouseDown","nativeEvent","onMouseUp","onTouchCancel","onTouchEnd","onTouchStart","role","tabIndex"],"sourceRoot":""}